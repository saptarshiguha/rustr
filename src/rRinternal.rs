/* automatically generated by rust-bindgen */
#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
use libc::size_t;
use libc::ptrdiff_t;
use libc::FILE;

#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed1 { FALSE = 0, TRUE = 1, }
pub type Rboolean = Enum_Unnamed1;

#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed2 {
    pub r: ::std::os::raw::c_double,
    pub i: ::std::os::raw::c_double,
}
impl ::std::clone::Clone for Struct_Unnamed2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Rcomplex = Struct_Unnamed2;

pub type Rbyte = ::std::os::raw::c_uchar;
pub type R_len_t = ::std::os::raw::c_int;
pub type R_xlen_t = ptrdiff_t;

#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed3 {
    pub lv_length: R_xlen_t,
    pub lv_truelength: R_xlen_t,
}
impl ::std::clone::Clone for Struct_Unnamed3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type R_long_vec_hdr_t = Struct_Unnamed3;
pub type SEXPTYPE = ::std::os::raw::c_uint;
pub enum Struct_SEXPREC { }
pub type SEXP = *mut Struct_SEXPREC;
pub type PROTECT_INDEX = ::std::os::raw::c_int;
pub enum Struct_R_allocator { }
pub type R_allocator_t = Struct_R_allocator;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed4 { Bytes = 0, Chars = 1, Width = 2, }
pub type nchar_type = Enum_Unnamed4;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed5 {
    CE_NATIVE = 0,
    CE_UTF8 = 1,
    CE_LATIN1 = 2,
    CE_BYTES = 3,
    CE_SYMBOL = 5,
    CE_ANY = 99,
}
pub type cetype_t = Enum_Unnamed5;
pub type R_CFinalizer_t = ::std::option::Option<extern "C" fn(arg1: SEXP)>;
pub type R_pstream_data_t = *mut ::std::os::raw::c_void;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed6 {
    R_pstream_any_format = 0,
    R_pstream_ascii_format = 1,
    R_pstream_binary_format = 2,
    R_pstream_xdr_format = 3,
    R_pstream_asciihex_format = 4,
}
pub type R_pstream_format_t = Enum_Unnamed6;
pub type R_outpstream_t = *mut Struct_R_outpstream_st;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_R_outpstream_st {
    pub data: R_pstream_data_t,
    pub _type: R_pstream_format_t,
    pub version: ::std::os::raw::c_int,
    pub OutChar: ::std::option::Option<extern "C" fn(arg1: R_outpstream_t,
                                                     arg2:
                                                         ::std::os::raw::c_int)>,
    pub OutBytes: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 R_outpstream_t,
                                                             arg2:
                                                                 *mut ::std::os::raw::c_void,
                                                             arg3:
                                                                 ::std::os::raw::c_int)>,
    pub OutPersistHookFunc: ::std::option::Option<extern "C" fn(arg1: SEXP,
                                                                arg2: SEXP)
                                                      -> SEXP>,
    pub OutPersistHookData: SEXP,
}
impl ::std::clone::Clone for Struct_R_outpstream_st {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_R_outpstream_st {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type R_inpstream_t = *mut Struct_R_inpstream_st;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_R_inpstream_st {
    pub data: R_pstream_data_t,
    pub _type: R_pstream_format_t,
    pub InChar: ::std::option::Option<extern "C" fn(arg1: R_inpstream_t)
                                          -> ::std::os::raw::c_int>,
    pub InBytes: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                R_inpstream_t,
                                                            arg2:
                                                                *mut ::std::os::raw::c_void,
                                                            arg3:
                                                                ::std::os::raw::c_int)>,
    pub InPersistHookFunc: ::std::option::Option<extern "C" fn(arg1: SEXP,
                                                               arg2: SEXP)
                                                     -> SEXP>,
    pub InPersistHookData: SEXP,
}
impl ::std::clone::Clone for Struct_R_inpstream_st {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_R_inpstream_st {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub static mut R_NaN: ::std::os::raw::c_double;
    pub static mut R_PosInf: ::std::os::raw::c_double;
    pub static mut R_NegInf: ::std::os::raw::c_double;
    pub static mut R_NaReal: ::std::os::raw::c_double;
    pub static mut R_NaInt: ::std::os::raw::c_int;
    pub static mut R_GlobalEnv: SEXP;
    pub static mut R_EmptyEnv: SEXP;
    pub static mut R_BaseEnv: SEXP;
    pub static mut R_BaseNamespace: SEXP;
    pub static mut R_NamespaceRegistry: SEXP;
    pub static mut R_Srcref: SEXP;
    pub static mut R_NilValue: SEXP;
    pub static mut R_UnboundValue: SEXP;
    pub static mut R_MissingArg: SEXP;
    pub static mut R_RestartToken: SEXP;
    pub static mut R_baseSymbol: SEXP;
    pub static mut R_BaseSymbol: SEXP;
    pub static mut R_BraceSymbol: SEXP;
    pub static mut R_Bracket2Symbol: SEXP;
    pub static mut R_BracketSymbol: SEXP;
    pub static mut R_ClassSymbol: SEXP;
    pub static mut R_DeviceSymbol: SEXP;
    pub static mut R_DimNamesSymbol: SEXP;
    pub static mut R_DimSymbol: SEXP;
    pub static mut R_DollarSymbol: SEXP;
    pub static mut R_DotsSymbol: SEXP;
    pub static mut R_DoubleColonSymbol: SEXP;
    pub static mut R_DropSymbol: SEXP;
    pub static mut R_LastvalueSymbol: SEXP;
    pub static mut R_LevelsSymbol: SEXP;
    pub static mut R_ModeSymbol: SEXP;
    pub static mut R_NaRmSymbol: SEXP;
    pub static mut R_NameSymbol: SEXP;
    pub static mut R_NamesSymbol: SEXP;
    pub static mut R_NamespaceEnvSymbol: SEXP;
    pub static mut R_PackageSymbol: SEXP;
    pub static mut R_PreviousSymbol: SEXP;
    pub static mut R_QuoteSymbol: SEXP;
    pub static mut R_RowNamesSymbol: SEXP;
    pub static mut R_SeedsSymbol: SEXP;
    pub static mut R_SortListSymbol: SEXP;
    pub static mut R_SourceSymbol: SEXP;
    pub static mut R_SpecSymbol: SEXP;
    pub static mut R_TripleColonSymbol: SEXP;
    pub static mut R_TspSymbol: SEXP;
    pub static mut R_dot_defined: SEXP;
    pub static mut R_dot_Method: SEXP;
    pub static mut R_dot_packageName: SEXP;
    pub static mut R_dot_target: SEXP;
    pub static mut R_NaString: SEXP;
    pub static mut R_BlankString: SEXP;
    pub static mut R_BlankScalarString: SEXP;
}
extern "C" {
    pub fn R_IsNA(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn R_IsNaN(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn R_finite(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn Rf_error(arg1: *const ::std::os::raw::c_char, ...);
    pub fn UNIMPLEMENTED(arg1: *const ::std::os::raw::c_char);
    pub fn WrongArgCount(arg1: *const ::std::os::raw::c_char);
    pub fn Rf_warning(arg1: *const ::std::os::raw::c_char, ...);
    pub fn R_ShowMessage(s: *const ::std::os::raw::c_char);
    pub fn vmaxget() -> *mut ::std::os::raw::c_void;
    pub fn vmaxset(arg1: *const ::std::os::raw::c_void);
    pub fn R_gc();
    pub fn R_gc_running() -> ::std::os::raw::c_int;
    pub fn R_alloc(arg1: size_t, arg2: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn R_allocLD(nelem: size_t) -> *mut ::std::os::raw::c_double;
    pub fn S_alloc(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn S_realloc(arg1: *mut ::std::os::raw::c_char,
                     arg2: ::std::os::raw::c_long,
                     arg3: ::std::os::raw::c_long,
                     arg4: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn R_isort(arg1: *mut ::std::os::raw::c_int,
                   arg2: ::std::os::raw::c_int);
    pub fn R_rsort(arg1: *mut ::std::os::raw::c_double,
                   arg2: ::std::os::raw::c_int);
    pub fn R_csort(arg1: *mut Rcomplex, arg2: ::std::os::raw::c_int);
    pub fn rsort_with_index(arg1: *mut ::std::os::raw::c_double,
                            arg2: *mut ::std::os::raw::c_int,
                            arg3: ::std::os::raw::c_int);
    pub fn Rf_revsort(arg1: *mut ::std::os::raw::c_double,
                      arg2: *mut ::std::os::raw::c_int,
                      arg3: ::std::os::raw::c_int);
    pub fn Rf_iPsort(arg1: *mut ::std::os::raw::c_int,
                     arg2: ::std::os::raw::c_int,
                     arg3: ::std::os::raw::c_int);
    pub fn Rf_rPsort(arg1: *mut ::std::os::raw::c_double,
                     arg2: ::std::os::raw::c_int,
                     arg3: ::std::os::raw::c_int);
    pub fn Rf_cPsort(arg1: *mut Rcomplex, arg2: ::std::os::raw::c_int,
                     arg3: ::std::os::raw::c_int);
    pub fn R_qsort(v: *mut ::std::os::raw::c_double, i: size_t, j: size_t);
    pub fn R_qsort_I(v: *mut ::std::os::raw::c_double,
                     II: *mut ::std::os::raw::c_int, i: ::std::os::raw::c_int,
                     j: ::std::os::raw::c_int);
    pub fn R_qsort_int(iv: *mut ::std::os::raw::c_int, i: size_t, j: size_t);
    pub fn R_qsort_int_I(iv: *mut ::std::os::raw::c_int,
                         II: *mut ::std::os::raw::c_int,
                         i: ::std::os::raw::c_int, j: ::std::os::raw::c_int);
    pub fn R_ExpandFileName(arg1: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
    pub fn Rf_setIVector(arg1: *mut ::std::os::raw::c_int,
                         arg2: ::std::os::raw::c_int,
                         arg3: ::std::os::raw::c_int);
    pub fn Rf_setRVector(arg1: *mut ::std::os::raw::c_double,
                         arg2: ::std::os::raw::c_int,
                         arg3: ::std::os::raw::c_double);
    pub fn Rf_StringFalse(arg1: *const ::std::os::raw::c_char) -> Rboolean;
    pub fn Rf_StringTrue(arg1: *const ::std::os::raw::c_char) -> Rboolean;
    pub fn Rf_isBlankString(arg1: *const ::std::os::raw::c_char) -> Rboolean;
    pub fn R_atof(str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn R_strtod(c: *const ::std::os::raw::c_char,
                    end: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn R_tmpnam(prefix: *const ::std::os::raw::c_char,
                    tempdir: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn R_tmpnam2(prefix: *const ::std::os::raw::c_char,
                     tempdir: *const ::std::os::raw::c_char,
                     fileext: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn R_CheckUserInterrupt();
    pub fn R_CheckStack();
    pub fn R_CheckStack2(arg1: size_t);
    pub fn findInterval(xt: *mut ::std::os::raw::c_double,
                        n: ::std::os::raw::c_int, x: ::std::os::raw::c_double,
                        rightmost_closed: Rboolean, all_inside: Rboolean,
                        ilo: ::std::os::raw::c_int,
                        mflag: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn find_interv_vec(xt: *mut ::std::os::raw::c_double,
                           n: *mut ::std::os::raw::c_int,
                           x: *mut ::std::os::raw::c_double,
                           nx: *mut ::std::os::raw::c_int,
                           rightmost_closed: *mut ::std::os::raw::c_int,
                           all_inside: *mut ::std::os::raw::c_int,
                           indx: *mut ::std::os::raw::c_int);
    pub fn R_max_col(matrix: *mut ::std::os::raw::c_double,
                     nr: *mut ::std::os::raw::c_int,
                     nc: *mut ::std::os::raw::c_int,
                     maxes: *mut ::std::os::raw::c_int,
                     ties_meth: *mut ::std::os::raw::c_int);
    pub fn Rprintf(arg1: *const ::std::os::raw::c_char, ...);
    pub fn REprintf(arg1: *const ::std::os::raw::c_char, ...);
    // pub fn Rvprintf(arg1: *const ::std::os::raw::c_char, arg2: va_list);
    // pub fn REvprintf(arg1: *const ::std::os::raw::c_char, arg2: va_list);
    pub fn R_CHAR(x: SEXP) -> *const ::std::os::raw::c_char;
    pub fn Rf_isNull(s: SEXP) -> Rboolean;
    pub fn Rf_isSymbol(s: SEXP) -> Rboolean;
    pub fn Rf_isLogical(s: SEXP) -> Rboolean;
    pub fn Rf_isReal(s: SEXP) -> Rboolean;
    pub fn Rf_isComplex(s: SEXP) -> Rboolean;
    pub fn Rf_isExpression(s: SEXP) -> Rboolean;
    pub fn Rf_isEnvironment(s: SEXP) -> Rboolean;
    pub fn Rf_isString(s: SEXP) -> Rboolean;
    pub fn Rf_isObject(s: SEXP) -> Rboolean;
    pub fn ATTRIB(x: SEXP) -> SEXP;
    pub fn OBJECT(x: SEXP) -> ::std::os::raw::c_int;
    pub fn MARK(x: SEXP) -> ::std::os::raw::c_int;
    pub fn TYPEOF(x: SEXP) -> ::std::os::raw::c_int;
    pub fn NAMED(x: SEXP) -> ::std::os::raw::c_int;
    pub fn REFCNT(x: SEXP) -> ::std::os::raw::c_int;
    pub fn SET_OBJECT(x: SEXP, v: ::std::os::raw::c_int);
    pub fn SET_TYPEOF(x: SEXP, v: ::std::os::raw::c_int);
    pub fn SET_NAMED(x: SEXP, v: ::std::os::raw::c_int);
    pub fn SET_ATTRIB(x: SEXP, v: SEXP);
    pub fn DUPLICATE_ATTRIB(to: SEXP, from: SEXP);
    pub fn IS_S4_OBJECT(x: SEXP) -> ::std::os::raw::c_int;
    pub fn SET_S4_OBJECT(x: SEXP);
    pub fn UNSET_S4_OBJECT(x: SEXP);
    pub fn LENGTH(x: SEXP) -> ::std::os::raw::c_int;
    pub fn TRUELENGTH(x: SEXP) -> ::std::os::raw::c_int;
    pub fn SETLENGTH(x: SEXP, v: ::std::os::raw::c_int);
    pub fn SET_TRUELENGTH(x: SEXP, v: ::std::os::raw::c_int);
    pub fn XLENGTH(x: SEXP) -> R_xlen_t;
    pub fn XTRUELENGTH(x: SEXP) -> R_xlen_t;
    pub fn IS_LONG_VEC(x: SEXP) -> ::std::os::raw::c_int;
    pub fn LEVELS(x: SEXP) -> ::std::os::raw::c_int;
    pub fn SETLEVELS(x: SEXP, v: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn LOGICAL(x: SEXP) -> *mut ::std::os::raw::c_int;
    pub fn INTEGER(x: SEXP) -> *mut ::std::os::raw::c_int;
    pub fn RAW(x: SEXP) -> *mut Rbyte;
    pub fn REAL(x: SEXP) -> *mut ::std::os::raw::c_double;
    pub fn COMPLEX(x: SEXP) -> *mut Rcomplex;
    pub fn STRING_ELT(x: SEXP, i: R_xlen_t) -> SEXP;
    pub fn VECTOR_ELT(x: SEXP, i: R_xlen_t) -> SEXP;
    pub fn SET_STRING_ELT(x: SEXP, i: R_xlen_t, v: SEXP);
    pub fn SET_VECTOR_ELT(x: SEXP, i: R_xlen_t, v: SEXP) -> SEXP;
    pub fn STRING_PTR(x: SEXP) -> *mut SEXP;
    pub fn VECTOR_PTR(x: SEXP) -> *mut SEXP;
    pub fn TAG(e: SEXP) -> SEXP;
    pub fn CAR(e: SEXP) -> SEXP;
    pub fn CDR(e: SEXP) -> SEXP;
    pub fn CAAR(e: SEXP) -> SEXP;
    pub fn CDAR(e: SEXP) -> SEXP;
    pub fn CADR(e: SEXP) -> SEXP;
    pub fn CDDR(e: SEXP) -> SEXP;
    pub fn CDDDR(e: SEXP) -> SEXP;
    pub fn CADDR(e: SEXP) -> SEXP;
    pub fn CADDDR(e: SEXP) -> SEXP;
    pub fn CAD4R(e: SEXP) -> SEXP;
    pub fn MISSING(x: SEXP) -> ::std::os::raw::c_int;
    pub fn SET_MISSING(x: SEXP, v: ::std::os::raw::c_int);
    pub fn SET_TAG(x: SEXP, y: SEXP);
    pub fn SETCAR(x: SEXP, y: SEXP) -> SEXP;
    pub fn SETCDR(x: SEXP, y: SEXP) -> SEXP;
    pub fn SETCADR(x: SEXP, y: SEXP) -> SEXP;
    pub fn SETCADDR(x: SEXP, y: SEXP) -> SEXP;
    pub fn SETCADDDR(x: SEXP, y: SEXP) -> SEXP;
    pub fn SETCAD4R(e: SEXP, y: SEXP) -> SEXP;
    pub fn CONS_NR(a: SEXP, b: SEXP) -> SEXP;
    pub fn FORMALS(x: SEXP) -> SEXP;
    pub fn BODY(x: SEXP) -> SEXP;
    pub fn CLOENV(x: SEXP) -> SEXP;
    pub fn RDEBUG(x: SEXP) -> ::std::os::raw::c_int;
    pub fn RSTEP(x: SEXP) -> ::std::os::raw::c_int;
    pub fn RTRACE(x: SEXP) -> ::std::os::raw::c_int;
    pub fn SET_RDEBUG(x: SEXP, v: ::std::os::raw::c_int);
    pub fn SET_RSTEP(x: SEXP, v: ::std::os::raw::c_int);
    pub fn SET_RTRACE(x: SEXP, v: ::std::os::raw::c_int);
    pub fn SET_FORMALS(x: SEXP, v: SEXP);
    pub fn SET_BODY(x: SEXP, v: SEXP);
    pub fn SET_CLOENV(x: SEXP, v: SEXP);
    pub fn PRINTNAME(x: SEXP) -> SEXP;
    pub fn SYMVALUE(x: SEXP) -> SEXP;
    pub fn INTERNAL(x: SEXP) -> SEXP;
    pub fn DDVAL(x: SEXP) -> ::std::os::raw::c_int;
    pub fn SET_DDVAL(x: SEXP, v: ::std::os::raw::c_int);
    pub fn SET_PRINTNAME(x: SEXP, v: SEXP);
    pub fn SET_SYMVALUE(x: SEXP, v: SEXP);
    pub fn SET_INTERNAL(x: SEXP, v: SEXP);
    pub fn FRAME(x: SEXP) -> SEXP;
    pub fn ENCLOS(x: SEXP) -> SEXP;
    pub fn HASHTAB(x: SEXP) -> SEXP;
    pub fn ENVFLAGS(x: SEXP) -> ::std::os::raw::c_int;
    pub fn SET_ENVFLAGS(x: SEXP, v: ::std::os::raw::c_int);
    pub fn SET_FRAME(x: SEXP, v: SEXP);
    pub fn SET_ENCLOS(x: SEXP, v: SEXP);
    pub fn SET_HASHTAB(x: SEXP, v: SEXP);
    pub fn PRCODE(x: SEXP) -> SEXP;
    pub fn PRENV(x: SEXP) -> SEXP;
    pub fn PRVALUE(x: SEXP) -> SEXP;
    pub fn PRSEEN(x: SEXP) -> ::std::os::raw::c_int;
    pub fn SET_PRSEEN(x: SEXP, v: ::std::os::raw::c_int);
    pub fn SET_PRENV(x: SEXP, v: SEXP);
    pub fn SET_PRVALUE(x: SEXP, v: SEXP);
    pub fn SET_PRCODE(x: SEXP, v: SEXP);
    pub fn HASHASH(x: SEXP) -> ::std::os::raw::c_int;
    pub fn HASHVALUE(x: SEXP) -> ::std::os::raw::c_int;
    pub fn SET_HASHASH(x: SEXP, v: ::std::os::raw::c_int);
    pub fn SET_HASHVALUE(x: SEXP, v: ::std::os::raw::c_int);
    pub fn R_GetCurrentSrcref(arg1: ::std::os::raw::c_int) -> SEXP;
    pub fn R_GetSrcFilename(arg1: SEXP) -> SEXP;
    pub fn Rf_asChar(arg1: SEXP) -> SEXP;
    pub fn Rf_coerceVector(arg1: SEXP, arg2: SEXPTYPE) -> SEXP;
    pub fn Rf_PairToVectorList(x: SEXP) -> SEXP;
    pub fn Rf_VectorToPairList(x: SEXP) -> SEXP;
    pub fn Rf_asCharacterFactor(x: SEXP) -> SEXP;
    pub fn Rf_asLogical(x: SEXP) -> ::std::os::raw::c_int;
    pub fn Rf_asInteger(x: SEXP) -> ::std::os::raw::c_int;
    pub fn Rf_asReal(x: SEXP) -> ::std::os::raw::c_double;
    pub fn Rf_asComplex(x: SEXP) -> Rcomplex;
    pub fn Rf_acopy_string(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn Rf_addMissingVarsToNewEnv(arg1: SEXP, arg2: SEXP);
    pub fn Rf_alloc3DArray(arg1: SEXPTYPE, arg2: ::std::os::raw::c_int,
                           arg3: ::std::os::raw::c_int,
                           arg4: ::std::os::raw::c_int) -> SEXP;
    pub fn Rf_allocArray(arg1: SEXPTYPE, arg2: SEXP) -> SEXP;
    pub fn Rf_allocFormalsList2(sym1: SEXP, sym2: SEXP) -> SEXP;
    pub fn Rf_allocFormalsList3(sym1: SEXP, sym2: SEXP, sym3: SEXP) -> SEXP;
    pub fn Rf_allocFormalsList4(sym1: SEXP, sym2: SEXP, sym3: SEXP,
                                sym4: SEXP) -> SEXP;
    pub fn Rf_allocFormalsList5(sym1: SEXP, sym2: SEXP, sym3: SEXP,
                                sym4: SEXP, sym5: SEXP) -> SEXP;
    pub fn Rf_allocFormalsList6(sym1: SEXP, sym2: SEXP, sym3: SEXP,
                                sym4: SEXP, sym5: SEXP, sym6: SEXP) -> SEXP;
    pub fn Rf_allocMatrix(arg1: SEXPTYPE, arg2: ::std::os::raw::c_int,
                          arg3: ::std::os::raw::c_int) -> SEXP;
    pub fn Rf_allocList(arg1: ::std::os::raw::c_int) -> SEXP;
    pub fn Rf_allocS4Object() -> SEXP;
    pub fn Rf_allocSExp(arg1: SEXPTYPE) -> SEXP;
    pub fn Rf_allocVector3(arg1: SEXPTYPE, arg2: R_xlen_t,
                           arg3: *mut R_allocator_t) -> SEXP;
    pub fn Rf_any_duplicated(x: SEXP, from_last: Rboolean) -> R_xlen_t;
    pub fn Rf_any_duplicated3(x: SEXP, incomp: SEXP, from_last: Rboolean)
     -> R_xlen_t;
    pub fn Rf_applyClosure(arg1: SEXP, arg2: SEXP, arg3: SEXP, arg4: SEXP,
                           arg5: SEXP) -> SEXP;
    pub fn Rf_arraySubscript(arg1: ::std::os::raw::c_int, arg2: SEXP,
                             arg3: SEXP,
                             arg4:
                                 ::std::option::Option<extern "C" fn(arg1:
                                                                         SEXP,
                                                                     arg2:
                                                                         SEXP)
                                                           -> SEXP>,
                             arg5:
                                 ::std::option::Option<extern "C" fn(arg1:
                                                                         SEXP,
                                                                     arg2:
                                                                         ::std::os::raw::c_int)
                                                           -> SEXP>,
                             arg6: SEXP) -> SEXP;
    pub fn Rf_classgets(arg1: SEXP, arg2: SEXP) -> SEXP;
    pub fn Rf_cons(arg1: SEXP, arg2: SEXP) -> SEXP;
    pub fn Rf_copyMatrix(arg1: SEXP, arg2: SEXP, arg3: Rboolean);
    pub fn Rf_copyListMatrix(arg1: SEXP, arg2: SEXP, arg3: Rboolean);
    pub fn Rf_copyMostAttrib(arg1: SEXP, arg2: SEXP);
    pub fn Rf_copyVector(arg1: SEXP, arg2: SEXP);
    pub fn Rf_countContexts(arg1: ::std::os::raw::c_int,
                            arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn Rf_CreateTag(arg1: SEXP) -> SEXP;
    pub fn Rf_defineVar(arg1: SEXP, arg2: SEXP, arg3: SEXP);
    pub fn Rf_dimgets(arg1: SEXP, arg2: SEXP) -> SEXP;
    pub fn Rf_dimnamesgets(arg1: SEXP, arg2: SEXP) -> SEXP;
    pub fn Rf_DropDims(arg1: SEXP) -> SEXP;
    pub fn Rf_duplicate(arg1: SEXP) -> SEXP;
    pub fn Rf_shallow_duplicate(arg1: SEXP) -> SEXP;
    pub fn Rf_lazy_duplicate(arg1: SEXP) -> SEXP;
    pub fn Rf_duplicated(arg1: SEXP, arg2: Rboolean) -> SEXP;
    pub fn R_envHasNoSpecialSymbols(arg1: SEXP) -> Rboolean;
    pub fn Rf_eval(arg1: SEXP, arg2: SEXP) -> SEXP;
    pub fn Rf_findFun(arg1: SEXP, arg2: SEXP) -> SEXP;
    pub fn Rf_findVar(arg1: SEXP, arg2: SEXP) -> SEXP;
    pub fn Rf_findVarInFrame(arg1: SEXP, arg2: SEXP) -> SEXP;
    pub fn Rf_findVarInFrame3(arg1: SEXP, arg2: SEXP, arg3: Rboolean) -> SEXP;
    pub fn Rf_getAttrib(arg1: SEXP, arg2: SEXP) -> SEXP;
    pub fn Rf_GetArrayDimnames(arg1: SEXP) -> SEXP;
    pub fn Rf_GetColNames(arg1: SEXP) -> SEXP;
    pub fn Rf_GetMatrixDimnames(arg1: SEXP, arg2: *mut SEXP, arg3: *mut SEXP,
                                arg4: *mut *const ::std::os::raw::c_char,
                                arg5: *mut *const ::std::os::raw::c_char);
    pub fn Rf_GetOption(arg1: SEXP, arg2: SEXP) -> SEXP;
    pub fn Rf_GetOption1(arg1: SEXP) -> SEXP;
    pub fn Rf_GetOptionDigits() -> ::std::os::raw::c_int;
    pub fn Rf_GetOptionWidth() -> ::std::os::raw::c_int;
    pub fn Rf_GetRowNames(arg1: SEXP) -> SEXP;
    pub fn Rf_gsetVar(arg1: SEXP, arg2: SEXP, arg3: SEXP);
    pub fn Rf_install(arg1: *const ::std::os::raw::c_char) -> SEXP;
    pub fn Rf_installChar(arg1: SEXP) -> SEXP;
    pub fn Rf_installDDVAL(i: ::std::os::raw::c_int) -> SEXP;
    pub fn Rf_installS3Signature(arg1: *const ::std::os::raw::c_char,
                                 arg2: *const ::std::os::raw::c_char) -> SEXP;
    pub fn Rf_isFree(arg1: SEXP) -> Rboolean;
    pub fn Rf_isOrdered(arg1: SEXP) -> Rboolean;
    pub fn Rf_isUnordered(arg1: SEXP) -> Rboolean;
    pub fn Rf_isUnsorted(arg1: SEXP, arg2: Rboolean) -> Rboolean;
    pub fn Rf_lengthgets(arg1: SEXP, arg2: R_len_t) -> SEXP;
    pub fn Rf_xlengthgets(arg1: SEXP, arg2: R_xlen_t) -> SEXP;
    pub fn R_lsInternal(arg1: SEXP, arg2: Rboolean) -> SEXP;
    pub fn R_lsInternal3(arg1: SEXP, arg2: Rboolean, arg3: Rboolean) -> SEXP;
    pub fn Rf_match(arg1: SEXP, arg2: SEXP, arg3: ::std::os::raw::c_int)
     -> SEXP;
    pub fn Rf_matchE(arg1: SEXP, arg2: SEXP, arg3: ::std::os::raw::c_int,
                     arg4: SEXP) -> SEXP;
    pub fn Rf_namesgets(arg1: SEXP, arg2: SEXP) -> SEXP;
    pub fn Rf_mkChar(arg1: *const ::std::os::raw::c_char) -> SEXP;
    pub fn Rf_mkCharLen(arg1: *const ::std::os::raw::c_char,
                        arg2: ::std::os::raw::c_int) -> SEXP;
    pub fn Rf_NonNullStringMatch(arg1: SEXP, arg2: SEXP) -> Rboolean;
    pub fn Rf_ncols(arg1: SEXP) -> ::std::os::raw::c_int;
    pub fn Rf_nrows(arg1: SEXP) -> ::std::os::raw::c_int;
    pub fn Rf_nthcdr(arg1: SEXP, arg2: ::std::os::raw::c_int) -> SEXP;
    pub fn R_nchar(string: SEXP, type_: nchar_type, allowNA: Rboolean,
                   keepNA: Rboolean, msg_name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn Rf_pmatch(arg1: SEXP, arg2: SEXP, arg3: Rboolean) -> Rboolean;
    pub fn Rf_psmatch(arg1: *const ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char, arg3: Rboolean)
     -> Rboolean;
    pub fn Rf_PrintValue(arg1: SEXP);
    pub fn Rf_readS3VarsFromFrame(arg1: SEXP, arg2: *mut SEXP,
                                  arg3: *mut SEXP, arg4: *mut SEXP,
                                  arg5: *mut SEXP, arg6: *mut SEXP,
                                  arg7: *mut SEXP);
    pub fn Rf_setAttrib(arg1: SEXP, arg2: SEXP, arg3: SEXP) -> SEXP;
    pub fn Rf_setSVector(arg1: *mut SEXP, arg2: ::std::os::raw::c_int,
                         arg3: SEXP);
    pub fn Rf_setVar(arg1: SEXP, arg2: SEXP, arg3: SEXP);
    pub fn Rf_stringSuffix(arg1: SEXP, arg2: ::std::os::raw::c_int) -> SEXP;
    pub fn Rf_str2type(arg1: *const ::std::os::raw::c_char) -> SEXPTYPE;
    pub fn Rf_StringBlank(arg1: SEXP) -> Rboolean;
    pub fn Rf_substitute(arg1: SEXP, arg2: SEXP) -> SEXP;
    pub fn Rf_translateChar(arg1: SEXP) -> *const ::std::os::raw::c_char;
    pub fn Rf_translateChar0(arg1: SEXP) -> *const ::std::os::raw::c_char;
    pub fn Rf_translateCharUTF8(arg1: SEXP) -> *const ::std::os::raw::c_char;
    pub fn Rf_type2char(arg1: SEXPTYPE) -> *const ::std::os::raw::c_char;
    pub fn Rf_type2rstr(arg1: SEXPTYPE) -> SEXP;
    pub fn Rf_type2str(arg1: SEXPTYPE) -> SEXP;
    pub fn Rf_type2str_nowarn(arg1: SEXPTYPE) -> SEXP;
    pub fn Rf_unprotect_ptr(arg1: SEXP);
    pub fn R_signal_protect_error();
    pub fn R_signal_unprotect_error();
    pub fn R_signal_reprotect_error(i: PROTECT_INDEX);
    pub fn R_tryEval(arg1: SEXP, arg2: SEXP, arg3: *mut ::std::os::raw::c_int)
     -> SEXP;
    pub fn R_tryEvalSilent(arg1: SEXP, arg2: SEXP,
                           arg3: *mut ::std::os::raw::c_int) -> SEXP;
    pub fn R_curErrorBuf() -> *const ::std::os::raw::c_char;
    pub fn Rf_isS4(arg1: SEXP) -> Rboolean;
    pub fn Rf_asS4(arg1: SEXP, arg2: Rboolean, arg3: ::std::os::raw::c_int)
     -> SEXP;
    pub fn Rf_S3Class(arg1: SEXP) -> SEXP;
    pub fn Rf_isBasicClass(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn R_cycle_detected(s: SEXP, child: SEXP) -> Rboolean;
    pub fn Rf_getCharCE(arg1: SEXP) -> cetype_t;
    pub fn Rf_mkCharCE(arg1: *const ::std::os::raw::c_char, arg2: cetype_t)
     -> SEXP;
    pub fn Rf_mkCharLenCE(arg1: *const ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int, arg3: cetype_t)
     -> SEXP;
    pub fn Rf_reEnc(x: *const ::std::os::raw::c_char, ce_in: cetype_t,
                    ce_out: cetype_t, subst: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn R_forceAndCall(e: SEXP, n: ::std::os::raw::c_int, rho: SEXP)
     -> SEXP;
    pub fn R_MakeExternalPtr(p: *mut ::std::os::raw::c_void, tag: SEXP,
                             prot: SEXP) -> SEXP;
    pub fn R_ExternalPtrAddr(s: SEXP) -> *mut ::std::os::raw::c_void;
    pub fn R_ExternalPtrTag(s: SEXP) -> SEXP;
    pub fn R_ExternalPtrProtected(s: SEXP) -> SEXP;
    pub fn R_ClearExternalPtr(s: SEXP);
    pub fn R_SetExternalPtrAddr(s: SEXP, p: *mut ::std::os::raw::c_void);
    pub fn R_SetExternalPtrTag(s: SEXP, tag: SEXP);
    pub fn R_SetExternalPtrProtected(s: SEXP, p: SEXP);
    pub fn R_RegisterFinalizer(s: SEXP, fun: SEXP);
    pub fn R_RegisterCFinalizer(s: SEXP, fun: R_CFinalizer_t);
    pub fn R_RegisterFinalizerEx(s: SEXP, fun: SEXP, onexit: Rboolean);
    pub fn R_RegisterCFinalizerEx(s: SEXP, fun: R_CFinalizer_t,
                                  onexit: Rboolean);
    pub fn R_RunPendingFinalizers();
    pub fn R_MakeWeakRef(key: SEXP, val: SEXP, fin: SEXP, onexit: Rboolean)
     -> SEXP;
    pub fn R_MakeWeakRefC(key: SEXP, val: SEXP, fin: R_CFinalizer_t,
                          onexit: Rboolean) -> SEXP;
    pub fn R_WeakRefKey(w: SEXP) -> SEXP;
    pub fn R_WeakRefValue(w: SEXP) -> SEXP;
    pub fn R_RunWeakRefFinalizer(w: SEXP);
    pub fn R_PromiseExpr(arg1: SEXP) -> SEXP;
    pub fn R_ClosureExpr(arg1: SEXP) -> SEXP;
    pub fn R_initialize_bcode();
    pub fn R_bcEncode(arg1: SEXP) -> SEXP;
    pub fn R_bcDecode(arg1: SEXP) -> SEXP;
    pub fn R_ToplevelExec(fun:
                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut ::std::os::raw::c_void)>,
                          data: *mut ::std::os::raw::c_void) -> Rboolean;
    pub fn R_ExecWithCleanup(fun:
                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                *mut ::std::os::raw::c_void)
                                                           -> SEXP>,
                             data: *mut ::std::os::raw::c_void,
                             cleanfun:
                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                *mut ::std::os::raw::c_void)>,
                             cleandata: *mut ::std::os::raw::c_void) -> SEXP;
    pub fn R_RestoreHashCount(rho: SEXP);
    pub fn R_IsPackageEnv(rho: SEXP) -> Rboolean;
    pub fn R_PackageEnvName(rho: SEXP) -> SEXP;
    pub fn R_FindPackageEnv(info: SEXP) -> SEXP;
    pub fn R_IsNamespaceEnv(rho: SEXP) -> Rboolean;
    pub fn R_NamespaceEnvSpec(rho: SEXP) -> SEXP;
    pub fn R_FindNamespace(info: SEXP) -> SEXP;
    pub fn R_LockEnvironment(env: SEXP, bindings: Rboolean);
    pub fn R_EnvironmentIsLocked(env: SEXP) -> Rboolean;
    pub fn R_LockBinding(sym: SEXP, env: SEXP);
    pub fn R_unLockBinding(sym: SEXP, env: SEXP);
    pub fn R_MakeActiveBinding(sym: SEXP, fun: SEXP, env: SEXP);
    pub fn R_BindingIsLocked(sym: SEXP, env: SEXP) -> Rboolean;
    pub fn R_BindingIsActive(sym: SEXP, env: SEXP) -> Rboolean;
    pub fn R_HasFancyBindings(rho: SEXP) -> Rboolean;
    pub fn Rf_errorcall(arg1: SEXP, arg2: *const ::std::os::raw::c_char, ...);
    pub fn Rf_warningcall(arg1: SEXP,
                          arg2: *const ::std::os::raw::c_char, ...);
    pub fn Rf_warningcall_immediate(arg1: SEXP,
                                    arg2: *const ::std::os::raw::c_char, ...);
    pub fn R_XDREncodeDouble(d: ::std::os::raw::c_double,
                             buf: *mut ::std::os::raw::c_void);
    pub fn R_XDRDecodeDouble(buf: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_double;
    pub fn R_XDREncodeInteger(i: ::std::os::raw::c_int,
                              buf: *mut ::std::os::raw::c_void);
    pub fn R_XDRDecodeInteger(buf: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn R_InitInPStream(stream: R_inpstream_t, data: R_pstream_data_t,
                           _type: R_pstream_format_t,
                           inchar:
                               ::std::option::Option<extern "C" fn(arg1:
                                                                       R_inpstream_t)
                                                         ->
                                                             ::std::os::raw::c_int>,
                           inbytes:
                               ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                              R_inpstream_t,
                                                                          arg2:
                                                                              *mut ::std::os::raw::c_void,
                                                                          arg3:
                                                                              ::std::os::raw::c_int)>,
                           phook:
                               ::std::option::Option<extern "C" fn(arg1: SEXP,
                                                                   arg2: SEXP)
                                                         -> SEXP>,
                           pdata: SEXP);
    pub fn R_InitOutPStream(stream: R_outpstream_t, data: R_pstream_data_t,
                            _type: R_pstream_format_t,
                            version: ::std::os::raw::c_int,
                            outchar:
                                ::std::option::Option<extern "C" fn(arg1:
                                                                        R_outpstream_t,
                                                                    arg2:
                                                                        ::std::os::raw::c_int)>,
                            outbytes:
                                ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                               R_outpstream_t,
                                                                           arg2:
                                                                               *mut ::std::os::raw::c_void,
                                                                           arg3:
                                                                               ::std::os::raw::c_int)>,
                            phook:
                                ::std::option::Option<extern "C" fn(arg1:
                                                                        SEXP,
                                                                    arg2:
                                                                        SEXP)
                                                          -> SEXP>,
                            pdata: SEXP);
    pub fn R_InitFileInPStream(stream: R_inpstream_t, fp: *mut FILE,
                               _type: R_pstream_format_t,
                               phook:
                                   ::std::option::Option<extern "C" fn(arg1:
                                                                           SEXP,
                                                                       arg2:
                                                                           SEXP)
                                                             -> SEXP>,
                               pdata: SEXP);
    pub fn R_InitFileOutPStream(stream: R_outpstream_t, fp: *mut FILE,
                                _type: R_pstream_format_t,
                                version: ::std::os::raw::c_int,
                                phook:
                                    ::std::option::Option<extern "C" fn(arg1:
                                                                            SEXP,
                                                                        arg2:
                                                                            SEXP)
                                                              -> SEXP>,
                                pdata: SEXP);
    pub fn R_Serialize(s: SEXP, ops: R_outpstream_t);
    pub fn R_Unserialize(ips: R_inpstream_t) -> SEXP;
    pub fn R_do_slot(obj: SEXP, name: SEXP) -> SEXP;
    pub fn R_do_slot_assign(obj: SEXP, name: SEXP, value: SEXP) -> SEXP;
    pub fn R_has_slot(obj: SEXP, name: SEXP) -> ::std::os::raw::c_int;
    pub fn R_do_MAKE_CLASS(what: *const ::std::os::raw::c_char) -> SEXP;
    pub fn R_getClassDef(what: *const ::std::os::raw::c_char) -> SEXP;
    pub fn R_getClassDef_R(what: SEXP) -> SEXP;
    pub fn R_has_methods_attached() -> Rboolean;
    pub fn R_isVirtualClass(class_def: SEXP, env: SEXP) -> Rboolean;
    pub fn R_extends(class1: SEXP, class2: SEXP, env: SEXP) -> Rboolean;
    pub fn R_do_new_object(class_def: SEXP) -> SEXP;
    pub fn R_check_class_and_super(x: SEXP,
                                   valid: *mut *const ::std::os::raw::c_char,
                                   rho: SEXP) -> ::std::os::raw::c_int;
    pub fn R_check_class_etc(x: SEXP,
                             valid: *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn R_PreserveObject(arg1: SEXP);
    pub fn R_ReleaseObject(arg1: SEXP);
    pub fn R_dot_Last();
    pub fn R_RunExitFinalizers();
    pub fn R_system(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn R_compute_identical(arg1: SEXP, arg2: SEXP,
                               arg3: ::std::os::raw::c_int) -> Rboolean;
    pub fn R_orderVector(indx: *mut ::std::os::raw::c_int,
                         n: ::std::os::raw::c_int, arglist: SEXP,
                         nalast: Rboolean, decreasing: Rboolean);
    pub fn Rf_allocVector(arg1: SEXPTYPE, arg2: R_xlen_t) -> SEXP;
    pub fn Rf_conformable(arg1: SEXP, arg2: SEXP) -> Rboolean;
    pub fn Rf_elt(arg1: SEXP, arg2: ::std::os::raw::c_int) -> SEXP;
    pub fn Rf_inherits(arg1: SEXP, arg2: *const ::std::os::raw::c_char)
     -> Rboolean;
    pub fn Rf_isArray(arg1: SEXP) -> Rboolean;
    pub fn Rf_isFactor(arg1: SEXP) -> Rboolean;
    pub fn Rf_isFrame(arg1: SEXP) -> Rboolean;
    pub fn Rf_isFunction(arg1: SEXP) -> Rboolean;
    pub fn Rf_isInteger(arg1: SEXP) -> Rboolean;
    pub fn Rf_isLanguage(arg1: SEXP) -> Rboolean;
    pub fn Rf_isList(arg1: SEXP) -> Rboolean;
    pub fn Rf_isMatrix(arg1: SEXP) -> Rboolean;
    pub fn Rf_isNewList(arg1: SEXP) -> Rboolean;
    pub fn Rf_isNumber(arg1: SEXP) -> Rboolean;
    pub fn Rf_isNumeric(arg1: SEXP) -> Rboolean;
    pub fn Rf_isPairList(arg1: SEXP) -> Rboolean;
    pub fn Rf_isPrimitive(arg1: SEXP) -> Rboolean;
    pub fn Rf_isTs(arg1: SEXP) -> Rboolean;
    pub fn Rf_isUserBinop(arg1: SEXP) -> Rboolean;
    pub fn Rf_isValidString(arg1: SEXP) -> Rboolean;
    pub fn Rf_isValidStringF(arg1: SEXP) -> Rboolean;
    pub fn Rf_isVector(arg1: SEXP) -> Rboolean;
    pub fn Rf_isVectorAtomic(arg1: SEXP) -> Rboolean;
    pub fn Rf_isVectorList(arg1: SEXP) -> Rboolean;
    pub fn Rf_isVectorizable(arg1: SEXP) -> Rboolean;
    pub fn Rf_lang1(arg1: SEXP) -> SEXP;
    pub fn Rf_lang2(arg1: SEXP, arg2: SEXP) -> SEXP;
    pub fn Rf_lang3(arg1: SEXP, arg2: SEXP, arg3: SEXP) -> SEXP;
    pub fn Rf_lang4(arg1: SEXP, arg2: SEXP, arg3: SEXP, arg4: SEXP) -> SEXP;
    pub fn Rf_lang5(arg1: SEXP, arg2: SEXP, arg3: SEXP, arg4: SEXP,
                    arg5: SEXP) -> SEXP;
    pub fn Rf_lang6(arg1: SEXP, arg2: SEXP, arg3: SEXP, arg4: SEXP,
                    arg5: SEXP, arg6: SEXP) -> SEXP;
    pub fn Rf_lastElt(arg1: SEXP) -> SEXP;
    pub fn Rf_lcons(arg1: SEXP, arg2: SEXP) -> SEXP;
    pub fn Rf_length(arg1: SEXP) -> R_len_t;
    pub fn Rf_list1(arg1: SEXP) -> SEXP;
    pub fn Rf_list2(arg1: SEXP, arg2: SEXP) -> SEXP;
    pub fn Rf_list3(arg1: SEXP, arg2: SEXP, arg3: SEXP) -> SEXP;
    pub fn Rf_list4(arg1: SEXP, arg2: SEXP, arg3: SEXP, arg4: SEXP) -> SEXP;
    pub fn Rf_list5(arg1: SEXP, arg2: SEXP, arg3: SEXP, arg4: SEXP,
                    arg5: SEXP) -> SEXP;
    pub fn Rf_listAppend(arg1: SEXP, arg2: SEXP) -> SEXP;
    pub fn Rf_mkNamed(arg1: SEXPTYPE,
                      arg2: *mut *const ::std::os::raw::c_char) -> SEXP;
    pub fn Rf_mkString(arg1: *const ::std::os::raw::c_char) -> SEXP;
    pub fn Rf_nlevels(arg1: SEXP) -> ::std::os::raw::c_int;
    pub fn Rf_stringPositionTr(arg1: SEXP,
                               arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn Rf_ScalarComplex(arg1: Rcomplex) -> SEXP;
    pub fn Rf_ScalarInteger(arg1: ::std::os::raw::c_int) -> SEXP;
    pub fn Rf_ScalarLogical(arg1: ::std::os::raw::c_int) -> SEXP;
    pub fn Rf_ScalarRaw(arg1: Rbyte) -> SEXP;
    pub fn Rf_ScalarReal(arg1: ::std::os::raw::c_double) -> SEXP;
    pub fn Rf_ScalarString(arg1: SEXP) -> SEXP;
    pub fn Rf_xlength(arg1: SEXP) -> R_xlen_t;
    pub fn Rf_protect(arg1: SEXP) -> SEXP;
    pub fn Rf_unprotect(arg1: ::std::os::raw::c_int);
    pub fn R_ProtectWithIndex(arg1: SEXP, arg2: *mut PROTECT_INDEX);
    pub fn R_Reprotect(arg1: SEXP, arg2: PROTECT_INDEX);
    pub fn R_FixupRHS(x: SEXP, y: SEXP) -> SEXP;
}
